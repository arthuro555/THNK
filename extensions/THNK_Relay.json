{
  "author": "",
  "category": "Network",
  "extensionNamespace": "",
  "fullName": "THNK Framework - Rooms adapter",
  "helpPath": "https://thnk.cloud/",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWxhbi1jb25uZWN0IiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTQsMUMyLjg5LDEgMiwxLjg5IDIsM1Y3QzIsOC4xMSAyLjg5LDkgNCw5SDFWMTFIMTNWOUgxMEMxMS4xMSw5IDEyLDguMTEgMTIsN1YzQzEyLDEuODkgMTEuMTEsMSAxMCwxSDRNNCwzSDEwVjdINFYzTTMsMTNWMThMMywyMEgxMFYxOEg1VjEzSDNNMTQsMTNDMTIuODksMTMgMTIsMTMuODkgMTIsMTVWMTlDMTIsMjAuMTEgMTIuODksMjEgMTQsMjFIMTFWMjNIMjNWMjFIMjBDMjEuMTEsMjEgMjIsMjAuMTEgMjIsMTlWMTVDMjIsMTMuODkgMjEuMTEsMTMgMjAsMTNIMTRNMTQsMTVIMjBWMTlIMTRWMTVaIiAvPjwvc3ZnPg==",
  "name": "THNK_Relay",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/lan-connect.svg",
  "shortDescription": "A THNK client adapter for connecting with a rooms system.",
  "version": "1.0.0",
  "description": [
    "> Note: This THNK adapter uses a relay server that is hosted for free. To help with the hosting costs and keeping this service up, consider [donating to the project](https://ko-fi.com/arthuro555)!",
    "",
    "This adapter allows to connect players together through a relay server. Players can create rooms with custom names or a randomly generated one, and other players can join those rooms.",
    "",
    "Additionally, those rooms can have tags, and you can query rooms by tags to discover rooms to connect to.",
    "",
    "You can host a relay server yourself too, if you so wish. Simply run the docker image `arthuro5555/thnk-relay:latest` on your server. You will need to open tcp port 6969 and udp port 9696. Example command: `docker run -p 6969:6969 -p 9696:9696/udp -d --restart always arthuro5555/thnk-relay:latest`."
  ],
  "tags": [
    "THNK",
    "adapter",
    "client",
    "server",
    "room",
    "code",
    "among us",
    "amogus",
    "multiplayer"
  ],
  "authorIds": [
    "ZgrsWuRTAkXgeuPV9bo0zuEcA2w1"
  ],
  "dependencies": [
    {
      "exportName": "@geckos.io/server",
      "name": "Geckos server",
      "type": "npm",
      "version": "^2.2.3"
    }
  ],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": "// Load THNK Cloud Relay Adapter (https://github.com/arthuro555/THNK)\n\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/@yandeu/events/cjs/version.js\n  var require_version = __commonJS({\n    \"node_modules/@yandeu/events/cjs/version.js\"(exports) {\n      \"use strict\";\n      Object.defineProperty(exports, \"__esModule\", { value: true });\n      exports.VERSION = void 0;\n      exports.VERSION = \"0.0.6\";\n    }\n  });\n\n  // node_modules/@yandeu/events/cjs/index.js\n  var require_cjs = __commonJS({\n    \"node_modules/@yandeu/events/cjs/index.js\"(exports) {\n      \"use strict\";\n      var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {\n        if (pack || arguments.length === 2)\n          for (var i = 0, l = from.length, ar; i < l; i++) {\n            if (ar || !(i in from)) {\n              if (!ar)\n                ar = Array.prototype.slice.call(from, 0, i);\n              ar[i] = from[i];\n            }\n          }\n        return to.concat(ar || Array.prototype.slice.call(from));\n      };\n      Object.defineProperty(exports, \"__esModule\", { value: true });\n      exports.Events = void 0;\n      var version_1 = require_version();\n      var EE = function() {\n        function EE2(fn, context, once) {\n          if (once === void 0) {\n            once = false;\n          }\n          this.fn = fn;\n          this.context = context;\n          this.once = once;\n        }\n        return EE2;\n      }();\n      var addListener = function(emitter, event, fn, context, once) {\n        if (typeof fn !== \"function\") {\n          throw new TypeError(\"The listener must be a function\");\n        }\n        var listener = new EE(fn, context || emitter, once);\n        if (!emitter._events.has(event))\n          emitter._events.set(event, listener), emitter._eventsCount++;\n        else if (!emitter._events.get(event).fn)\n          emitter._events.get(event).push(listener);\n        else\n          emitter._events.set(event, [emitter._events.get(event), listener]);\n        return emitter;\n      };\n      var clearEvent = function(emitter, event) {\n        if (--emitter._eventsCount === 0)\n          emitter._events = /* @__PURE__ */ new Map();\n        else\n          emitter._events.delete(event);\n      };\n      var Events2 = function() {\n        function Events3() {\n          this._events = /* @__PURE__ */ new Map();\n          this._eventsCount = 0;\n        }\n        Object.defineProperty(Events3, \"VERSION\", {\n          get: function() {\n            return version_1.VERSION;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Events3.prototype.eventNames = function() {\n          return Array.from(this._events.keys());\n        };\n        Events3.prototype.listeners = function(event) {\n          var handlers = this._events.get(event);\n          if (!handlers)\n            return [];\n          if (handlers.fn)\n            return [handlers.fn];\n          for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n            ee[i] = handlers[i].fn;\n          }\n          return ee;\n        };\n        Events3.prototype.listenerCount = function(event) {\n          var listeners = this._events.get(event);\n          if (!listeners)\n            return 0;\n          if (listeners.fn)\n            return 1;\n          return listeners.length;\n        };\n        Events3.prototype.emit = function(event) {\n          var _a, _b;\n          var args = [];\n          for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n          }\n          if (!this._events.has(event))\n            return false;\n          var listeners = this._events.get(event);\n          var i;\n          if (listeners.fn) {\n            if (listeners.once)\n              this.removeListener(event, listeners.fn, void 0, true);\n            return (_a = listeners.fn).call.apply(_a, __spreadArray([listeners.context], args, false)), true;\n          } else {\n            var length_1 = listeners.length;\n            for (i = 0; i < length_1; i++) {\n              if (listeners[i].once)\n                this.removeListener(event, listeners[i].fn, void 0, true);\n              (_b = listeners[i].fn).call.apply(_b, __spreadArray([listeners[i].context], args, false));\n            }\n          }\n          return true;\n        };\n        Events3.prototype.on = function(event, fn, context) {\n          return addListener(this, event, fn, context, false);\n        };\n        Events3.prototype.once = function(event, fn, context) {\n          return addListener(this, event, fn, context, true);\n        };\n        Events3.prototype.removeListener = function(event, fn, context, once) {\n          if (!this._events.has(event))\n            return this;\n          if (!fn) {\n            clearEvent(this, event);\n            return this;\n          }\n          var listeners = this._events.get(event);\n          if (listeners.fn) {\n            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n              clearEvent(this, event);\n            }\n          } else {\n            for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n              if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                events.push(listeners[i]);\n              }\n            }\n            if (events.length)\n              this._events.set(event, events.length === 1 ? events[0] : events);\n            else\n              clearEvent(this, event);\n          }\n          return this;\n        };\n        Events3.prototype.removeAllListeners = function(event) {\n          if (event) {\n            if (this._events.delete(event))\n              clearEvent(this, event);\n          } else {\n            this._events = /* @__PURE__ */ new Map();\n            this._eventsCount = 0;\n          }\n          return this;\n        };\n        Object.defineProperty(Events3.prototype, \"off\", {\n          get: function() {\n            return this.removeListener;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Events3.prototype, \"addListener\", {\n          get: function() {\n            return this.on;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        return Events3;\n      }();\n      exports.Events = Events2;\n    }\n  });\n\n  // node_modules/@geckos.io/common/lib/bridge.js\n  var import_events = __toESM(require_cjs(), 1);\n  var Bridge = class {\n    constructor() {\n      this.eventEmitter = new import_events.Events();\n    }\n    emit(eventName, data, connection = {}) {\n      this.eventEmitter.emit(eventName, data, connection);\n    }\n    on(eventName, cb) {\n      return this.eventEmitter.on(eventName, (data, options) => {\n        cb(data, options);\n      });\n    }\n    removeAllListeners() {\n      this.eventEmitter.removeAllListeners();\n    }\n  };\n  var bridge = new Bridge();\n\n  // node_modules/@geckos.io/common/lib/constants.js\n  var EVENTS = {\n    CONNECT: \"connect\",\n    CONNECTION: \"connection\",\n    DATA_CHANNEL_IS_OPEN: \"dataChannelIsOpen\",\n    DISCONNECT: \"disconnect\",\n    DISCONNECTED: \"disconnected\",\n    DROP: \"dropped\",\n    ERROR: \"error\",\n    RAW_MESSAGE: \"rawMessage\",\n    RECEIVED_FROM_DATA_CHANNEL: \"receiveFromDataChannel\",\n    SEND_OVER_DATA_CHANNEL: \"sendOverDataChannel\"\n  };\n  var ERRORS = {\n    BROWSER_NOT_SUPPORTED: \"BROWSER_NOT_SUPPORTED\",\n    COULD_NOT_PARSE_MESSAGE: \"COULD_NOT_PARSE_MESSAGE\",\n    DROPPED_FROM_BUFFERING: \"DROPPED_FROM_BUFFERING\",\n    MAX_MESSAGE_SIZE_EXCEEDED: \"MAX_MESSAGE_SIZE_EXCEEDED\"\n  };\n\n  // node_modules/@geckos.io/common/lib/types.js\n  var ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\n  // node_modules/@geckos.io/common/lib/helpers.js\n  var tick = typeof Promise == \"function\" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout;\n  var isStringMessage = (data) => {\n    return typeof data === \"string\";\n  };\n  var isBufferMessage = (data) => {\n    return data instanceof ArrayBuffer || data instanceof ArrayBufferView;\n  };\n  var isJSONMessage = (data) => {\n    try {\n      if (typeof data !== \"string\")\n        return false;\n      if (!isNaN(parseInt(data)))\n        return false;\n      JSON.parse(data);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  };\n\n  // node_modules/@geckos.io/common/lib/parseMessage.js\n  var ParseMessage = (ev) => {\n    let { data } = ev;\n    if (!data)\n      data = ev;\n    const isBuffer = isBufferMessage(data);\n    const isJson = isJSONMessage(data);\n    const isString = isStringMessage(data);\n    if (isJson) {\n      const object = JSON.parse(data);\n      const key = Object.keys(object)[0];\n      const value = object[key];\n      return { key, data: value };\n    }\n    if (isBuffer) {\n      return { key: EVENTS.RAW_MESSAGE, data };\n    }\n    if (isString) {\n      return { key: EVENTS.RAW_MESSAGE, data };\n    }\n    return { key: \"error\", data: new Error(ERRORS.COULD_NOT_PARSE_MESSAGE) };\n  };\n  var parseMessage_default = ParseMessage;\n\n  // node_modules/@geckos.io/common/lib/sendMessage.js\n  var SendMessage = (dataChannel, maxMessageSize, eventName, data = null) => {\n    var _a;\n    const send = (data2, isBuffer) => {\n      var _a2;\n      const bytes = (_a2 = data2.byteLength) !== null && _a2 !== void 0 ? _a2 : data2.length * 2;\n      if (typeof maxMessageSize === \"number\" && bytes > maxMessageSize) {\n        throw new Error(`maxMessageSize of ${maxMessageSize} exceeded`);\n      } else {\n        Promise.resolve().then(() => {\n          if (dataChannel.send)\n            dataChannel.send(data2);\n          else {\n            if (!isBuffer)\n              dataChannel.sendMessage(data2);\n            else\n              dataChannel.sendMessageBinary(Buffer.from(data2));\n          }\n        }).catch((error) => {\n          console.log(\"error\", error);\n        });\n      }\n    };\n    if (!dataChannel)\n      return;\n    if (dataChannel.readyState === \"open\" || ((_a = dataChannel.isOpen) === null || _a === void 0 ? void 0 : _a.call(dataChannel))) {\n      try {\n        if (eventName === EVENTS.RAW_MESSAGE && data !== null && (isStringMessage(data) || isBufferMessage(data))) {\n          send(data, isBufferMessage(data));\n        } else {\n          send(JSON.stringify({ [eventName]: data }), false);\n        }\n      } catch (error) {\n        console.error(\"Error in sendMessage.ts: \", error.message);\n        return error;\n      }\n    }\n  };\n  var sendMessage_default = SendMessage;\n\n  // node_modules/@geckos.io/client/lib/wrtc/connectionsManager.js\n  var ConnectionsManagerClient = class {\n    constructor(url, authorization, label, rtcConfiguration) {\n      this.url = url;\n      this.authorization = authorization;\n      this.label = label;\n      this.rtcConfiguration = rtcConfiguration;\n      this.bridge = new Bridge();\n      this.onDataChannel = (ev) => {\n        const { channel } = ev;\n        if (channel.label !== this.label)\n          return;\n        this.dataChannel = channel;\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.onmessage = (ev2) => {\n          const { key, data } = parseMessage_default(ev2);\n          this.bridge.emit(key, data);\n        };\n      };\n    }\n    emit(eventName, data = null) {\n      sendMessage_default(this.dataChannel, this.maxMessageSize, eventName, data);\n    }\n    async fetchAdditionalCandidates(host, id) {\n      var _a;\n      if (((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.readyState) === \"closed\")\n        return;\n      const res = await fetch(`${host}/connections/${id}/additional-candidates`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (res.ok) {\n        const candidates = await res.json();\n        candidates.forEach((c) => {\n          this.localPeerConnection.addIceCandidate(c);\n        });\n      }\n    }\n    async connect() {\n      const host = `${this.url}/.wrtc/v2`;\n      let headers = { \"Content-Type\": \"application/json\" };\n      if (this.authorization)\n        headers = { ...headers, [\"Authorization\"]: this.authorization };\n      let userData = {};\n      try {\n        const res = await fetch(`${host}/connections`, {\n          method: \"POST\",\n          headers\n        });\n        if (res.status >= 300) {\n          throw {\n            name: \"Error\",\n            message: `Connection failed with status code ${res.status}.`,\n            status: res.status,\n            statusText: res.statusText\n          };\n        }\n        const json = await res.json();\n        userData = json.userData;\n        this.remotePeerConnection = json;\n      } catch (error) {\n        console.error(error.message);\n        return { error };\n      }\n      const { id, localDescription } = this.remotePeerConnection;\n      const configuration = {\n        sdpSemantics: \"unified-plan\",\n        ...this.rtcConfiguration\n      };\n      const RTCPc = RTCPeerConnection || webkitRTCPeerConnection;\n      this.localPeerConnection = new RTCPc(configuration);\n      const showBackOffIntervals = (attempts = 10, initial = 50, factor = 1.8, jitter = 20) => Array(attempts).fill(0).map((_, index) => parseInt((initial * factor ** index).toString()) + parseInt((Math.random() * jitter).toString()));\n      showBackOffIntervals().forEach((ms) => {\n        setTimeout(() => {\n          this.fetchAdditionalCandidates(host, id).catch(() => {\n          });\n        }, ms);\n      });\n      try {\n        await this.localPeerConnection.setRemoteDescription(localDescription);\n        this.localPeerConnection.addEventListener(\"datachannel\", this.onDataChannel, { once: true });\n        const originalAnswer = await this.localPeerConnection.createAnswer();\n        const updatedAnswer = new RTCSessionDescription({\n          type: \"answer\",\n          sdp: originalAnswer.sdp\n        });\n        await this.localPeerConnection.setLocalDescription(updatedAnswer);\n        try {\n          await fetch(`${host}/connections/${id}/remote-description`, {\n            method: \"POST\",\n            body: JSON.stringify(this.localPeerConnection.localDescription),\n            headers: {\n              \"Content-Type\": \"application/json\"\n            }\n          });\n        } catch (error) {\n          console.error(error.message);\n          return { error };\n        }\n        const waitForDataChannel = () => {\n          return new Promise((resolve) => {\n            this.localPeerConnection.addEventListener(\"datachannel\", () => {\n              resolve();\n            }, { once: true });\n          });\n        };\n        if (!this.dataChannel)\n          await waitForDataChannel();\n        return {\n          userData,\n          localPeerConnection: this.localPeerConnection,\n          dataChannel: this.dataChannel,\n          id\n        };\n      } catch (error) {\n        console.error(error.message);\n        this.localPeerConnection.close();\n        return { error };\n      }\n    }\n  };\n\n  // node_modules/@geckos.io/client/lib/wrtc/peerConnection.js\n  var PeerConnection = class {\n    async connect(connectionsManager) {\n      const webRTCPcSupported = RTCPeerConnection || webkitRTCPeerConnection;\n      if (webRTCPcSupported) {\n        const { localPeerConnection, dataChannel, id, userData, error } = await connectionsManager.connect();\n        if (error)\n          return { error };\n        if (!localPeerConnection || !dataChannel || !id || !userData)\n          return { error: new Error('Something went wrong in \"await connectionsManager.connect()\"') };\n        this.localPeerConnection = localPeerConnection;\n        this.dataChannel = dataChannel;\n        this.id = id;\n        return { userData };\n      } else {\n        const error = new Error(ERRORS.BROWSER_NOT_SUPPORTED);\n        console.error(error.message);\n        return { error };\n      }\n    }\n  };\n\n  // node_modules/@geckos.io/common/lib/makeRandomId.js\n  var makeRandomId = (length = 24) => {\n    const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let id = \"\";\n    for (let i = 0; i < length; i++) {\n      id += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return id;\n  };\n  var makeRandomId_default = makeRandomId;\n\n  // node_modules/@geckos.io/common/lib/runInterval.js\n  var runInterval = (interval = 200, runs = 1, cb) => {\n    let counter = 0;\n    if (typeof cb !== \"function\") {\n      console.error(\"You have to define your callback function!\");\n      return;\n    }\n    const i = setInterval(() => {\n      cb();\n      counter++;\n      if (counter === runs - 1) {\n        clearInterval(i);\n      }\n    }, interval);\n    cb();\n  };\n  var runInterval_default = runInterval;\n\n  // node_modules/@geckos.io/common/lib/reliableMessage.js\n  var makeReliable = (options, cb) => {\n    const { interval = 150, runs = 10 } = options;\n    const id = makeRandomId_default(24);\n    runInterval_default(interval, runs, () => {\n      cb(id);\n    });\n  };\n\n  // node_modules/@geckos.io/client/lib/geckos/channel.js\n  var ClientChannel = class {\n    constructor(url, authorization, port, label, rtcConfiguration) {\n      this.userData = {};\n      this.receivedReliableMessages = [];\n      this.url = port ? `${url}:${port}` : url;\n      this.connectionsManager = new ConnectionsManagerClient(this.url, authorization, label, rtcConfiguration);\n      this.bridge = this.connectionsManager.bridge;\n      this.bridge.on(EVENTS.DISCONNECTED, () => this.bridge.removeAllListeners());\n    }\n    onconnectionstatechange() {\n      const lpc = this.peerConnection.localPeerConnection;\n      lpc.onconnectionstatechange = () => {\n        if (lpc.connectionState === \"disconnected\" || lpc.connectionState === \"closed\")\n          this.bridge.emit(EVENTS.DISCONNECTED);\n      };\n    }\n    get id() {\n      return this.peerConnection.id;\n    }\n    close() {\n      this.peerConnection.localPeerConnection.close();\n      this.bridge.emit(EVENTS.DISCONNECTED);\n      try {\n        const host = `${this.url}/.wrtc/v2`;\n        fetch(`${host}/connections/${this.id}/close`, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          }\n        });\n      } catch (error) {\n        console.error(error.message);\n      }\n    }\n    emit(eventName, data = null, options) {\n      if (options && options.reliable) {\n        makeReliable(options, (id) => this.connectionsManager.emit(eventName, {\n          MESSAGE: data,\n          RELIABLE: 1,\n          ID: id\n        }));\n      } else {\n        this.connectionsManager.emit(eventName, data);\n      }\n    }\n    get raw() {\n      return {\n        emit: (rawMessage) => this.emit(EVENTS.RAW_MESSAGE, rawMessage)\n      };\n    }\n    onRaw(callback) {\n      this.bridge.on(EVENTS.RAW_MESSAGE, (rawMessage) => {\n        const cb = (rawMessage2) => callback(rawMessage2);\n        cb(rawMessage);\n      });\n    }\n    async onConnect(callback) {\n      var _a;\n      this.peerConnection = new PeerConnection();\n      const response = await this.peerConnection.connect(this.connectionsManager);\n      if (response.error)\n        callback(response.error);\n      else {\n        if (response.userData)\n          this.userData = response.userData;\n        this.maxMessageSize = this.connectionsManager.maxMessageSize = (_a = this.peerConnection.localPeerConnection.sctp) === null || _a === void 0 ? void 0 : _a.maxMessageSize;\n        this.onconnectionstatechange();\n        callback();\n      }\n    }\n    onDisconnect(callback) {\n      this.bridge.on(EVENTS.DISCONNECTED, callback);\n    }\n    on(eventName, callback) {\n      this.bridge.on(eventName, (data) => {\n        const isReliableMessage = data && data.RELIABLE === 1 && data.ID !== \"undefined\";\n        const expireTime = 15e3;\n        const deleteExpiredReliableMessages = () => {\n          const currentTime = new Date().getTime();\n          this.receivedReliableMessages.forEach((msg, index, object) => {\n            if (msg.expire <= currentTime) {\n              object.splice(index, 1);\n            }\n          });\n        };\n        if (isReliableMessage) {\n          deleteExpiredReliableMessages();\n          if (this.receivedReliableMessages.filter((obj) => obj.id === data.ID).length === 0) {\n            this.receivedReliableMessages.push({\n              id: data.ID,\n              timestamp: new Date(),\n              expire: new Date().getTime() + expireTime\n            });\n            callback(data.MESSAGE);\n          } else {\n          }\n        } else {\n          callback(data);\n        }\n      });\n    }\n  };\n  var geckosClient = (options = {}) => {\n    const { authorization = void 0, iceServers = [], iceTransportPolicy = \"all\", label = \"geckos.io\", port = 9208, url = `${location.protocol}//${location.hostname}` } = options;\n    return new ClientChannel(url, authorization, port, label, { iceServers, iceTransportPolicy });\n  };\n  var channel_default = geckosClient;\n\n  // code/adapters/relay.ts\n  var SERVER_URL = \"http://localhost\";\n  THNK.RelayClientAdapter = class RelayClientAdapter extends THNK.ClientAdapter {\n    connection;\n    connected = false;\n    error;\n    constructor(gameID, roomID) {\n      super();\n      this.connection = channel_default({\n        url: SERVER_URL,\n        port: 6969,\n        label: \"THNK-Relay\",\n        authorization: JSON.stringify({\n          type: \"client\",\n          gameID,\n          roomID\n        })\n      });\n      this.connection.onConnect((error) => {\n        if (error)\n          this.error = error;\n        else\n          this.connected = true;\n      });\n      this.connection.onDisconnect(() => this.onDisconnection());\n      this.connection.onRaw((message) => this.onMessage(message));\n    }\n    async prepare() {\n      if (this.error)\n        throw this.error;\n      if (this.connected)\n        return;\n      await new Promise((resolve) => {\n        let checkIfConnected;\n        (checkIfConnected = () => {\n          if (this.error)\n            throw this.error;\n          if (this.connected)\n            return resolve();\n          setTimeout(checkIfConnected, 500);\n        })();\n      });\n    }\n    close() {\n      this.connection.close();\n    }\n    doSendMessage(message) {\n      this.connection.raw.emit(\n        message.buffer.slice(message.buffer.byteLength - message.byteLength)\n      );\n    }\n  };\n  THNK.RelayServerAdapter = class GeckosServerAdapter extends THNK.ServerAdapter {\n    connection;\n    connected = false;\n    error;\n    constructor(gameID, roomID) {\n      super();\n      this.connection = channel_default({\n        url: SERVER_URL,\n        port: 6969,\n        label: \"THNK-Relay\",\n        authorization: JSON.stringify({\n          type: \"server\",\n          gameID,\n          roomID\n        })\n      });\n      this.connection.onConnect((error) => {\n        if (error)\n          this.error = error;\n        else\n          this.connected = true;\n      });\n      this.connection.onDisconnect(() => this.close());\n      this.connection.on(\n        \"msg\",\n        ({ from, data }) => this.onMessage(from, data)\n      );\n      this.connection.on(\n        \"connect\",\n        ({ userID }) => this.onConnection(userID)\n      );\n      this.connection.on(\n        \"disconnect\",\n        ({ userID }) => this.onDisconnection(userID)\n      );\n    }\n    async prepare() {\n      if (this.error)\n        throw this.error;\n      if (this.connected)\n        return;\n      await new Promise((resolve) => {\n        let checkIfConnected;\n        (checkIfConnected = () => {\n          if (this.error)\n            throw this.error;\n          if (this.connected)\n            return resolve();\n          setTimeout(checkIfConnected, 500);\n        })();\n      });\n    }\n    close() {\n      this.connection.close();\n    }\n    doSendMessageTo(userID, message) {\n      this.connection.emit(\"msg\", {\n        to: userID,\n        data: message.buffer.slice(\n          message.buffer.byteLength - message.byteLength\n        )\n      });\n    }\n    getServerID() {\n      return this.connection.id;\n    }\n  };\n})();\n/**\n * @package      npmjs.com/package/@yandeu/events (events.min.js)\n *\n * @author       Arnout Kazemier (https://github.com/3rd-Eden)\n * @copyright    Copyright (c) 2014 Arnout Kazemier\n * @license      {@link https://github.com/primus/eventemitter3/blob/master/LICENSE|MIT}\n *\n * @author       Yannick Deubel (https://github.com/yandeu)\n * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/yandeu/events\n * @license      {@link https://github.com/yandeu/events/blob/master/LICENSE|MIT}\n */\n",
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Claim a room on the relay and start a server on it.",
      "fullName": "Create a room",
      "functionType": "Action",
      "name": "StartServer",
      "sentence": "Start scene _PARAM2_ as a server on relay room _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "THNK.server.startServer(",
            "    new THNK.RelayServerAdapter(",
            "        runtimeScene.getGame().getGameData().properties.projectUuid + runtimeScene.getGame().getGameData().properties.packageName,",
            "        eventsFunctionContext.getArgument(\"RoomID\")",
            "    ),",
            "    runtimeScene,",
            "    eventsFunctionContext.getArgument(\"Scene\")",
            ");",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "The ID of the room to create",
          "name": "RoomID",
          "type": "string"
        },
        {
          "description": "The scene to start the server with",
          "name": "Scene",
          "type": "sceneName"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Join a room on the relay and connect to the server on it.",
      "fullName": "Join a room",
      "functionType": "Action",
      "name": "ConnectToServer",
      "sentence": "Connect to the server on relay room _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "THNK.client.startClient(",
            "    runtimeScene,",
            "    new THNK.RelayClientAdapter(",
            "        runtimeScene.getGame().getGameData().properties.projectUuid + runtimeScene.getGame().getGameData().properties.packageName,",
            "        eventsFunctionContext.getArgument(\"RoomID\")",
            "    )",
            ");",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "The ID of the room to join",
          "name": "RoomID",
          "type": "string"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}