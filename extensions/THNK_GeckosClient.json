{
  "author": "",
  "category": "Network",
  "description": "A THNK client adapter for networking via [geckos.io](https://geckos.io), a client-server netwroking solution that uses fast UDP and encrypted connections.",
  "extensionNamespace": "",
  "fullName": "THNK Geckos.io Client adapter",
  "helpPath": "",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWxhbi1jb25uZWN0IiB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCI+PHBhdGggZD0iTTQsMUMyLjg5LDEgMiwxLjg5IDIsM1Y3QzIsOC4xMSAyLjg5LDkgNCw5SDFWMTFIMTNWOUgxMEMxMS4xMSw5IDEyLDguMTEgMTIsN1YzQzEyLDEuODkgMTEuMTEsMSAxMCwxSDRNNCwzSDEwVjdINFYzTTMsMTNWMThMMywyMEgxMFYxOEg1VjEzSDNNMTQsMTNDMTIuODksMTMgMTIsMTMuODkgMTIsMTVWMTlDMTIsMjAuMTEgMTIuODksMjEgMTQsMjFIMTFWMjNIMjNWMjFIMjBDMjEuMTEsMjEgMjIsMjAuMTEgMjIsMTlWMTVDMjIsMTMuODkgMjEuMTEsMTMgMjAsMTNIMTRNMTQsMTVIMjBWMTlIMTRWMTVaIiAvPjwvc3ZnPg==",
  "name": "THNK_GeckosClient",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/lan-connect.svg",
  "shortDescription": "A THNK client adapter for networking via geckos.io",
  "version": "1.0.0",
  "tags": [
    "THNK",
    "adapter",
    "client",
    "gecko",
    "io"
  ],
  "authorIds": [
    "ZgrsWuRTAkXgeuPV9bo0zuEcA2w1"
  ],
  "dependencies": [
    {
      "exportName": "@geckos.io/server",
      "name": "Geckos server",
      "type": "npm",
      "version": "^2.2.3"
    }
  ],
  "eventsFunctions": [
    {
      "description": "",
      "fullName": "",
      "functionType": "Action",
      "group": "",
      "name": "onFirstSceneLoaded",
      "private": false,
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": "// Load THNK Geckos Client Adapter (https://github.com/arthuro555/THNK)\n\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __commonJS = (cb, mod) => function __require() {\n    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(\n    isNodeMode || !mod || !mod.__esModule ? __defProp(target, \"default\", { value: mod, enumerable: true }) : target,\n    mod\n  ));\n\n  // node_modules/@yandeu/events/cjs/version.js\n  var require_version = __commonJS({\n    \"node_modules/@yandeu/events/cjs/version.js\"(exports) {\n      \"use strict\";\n      Object.defineProperty(exports, \"__esModule\", { value: true });\n      exports.VERSION = void 0;\n      exports.VERSION = \"0.0.5\";\n    }\n  });\n\n  // node_modules/@yandeu/events/cjs/index.js\n  var require_cjs = __commonJS({\n    \"node_modules/@yandeu/events/cjs/index.js\"(exports) {\n      \"use strict\";\n      var __spreadArray = exports && exports.__spreadArray || function(to, from) {\n        for (var i = 0, il = from.length, j = to.length; i < il; i++, j++)\n          to[j] = from[i];\n        return to;\n      };\n      Object.defineProperty(exports, \"__esModule\", { value: true });\n      exports.Events = void 0;\n      var version_1 = require_version();\n      var EE = function() {\n        function EE2(fn, context, once) {\n          if (once === void 0) {\n            once = false;\n          }\n          this.fn = fn;\n          this.context = context;\n          this.once = once;\n        }\n        return EE2;\n      }();\n      var addListener = function(emitter, event, fn, context, once) {\n        if (typeof fn !== \"function\") {\n          throw new TypeError(\"The listener must be a function\");\n        }\n        var listener = new EE(fn, context || emitter, once);\n        if (!emitter._events.has(event))\n          emitter._events.set(event, listener), emitter._eventsCount++;\n        else if (!emitter._events.get(event).fn)\n          emitter._events.get(event).push(listener);\n        else\n          emitter._events.set(event, [emitter._events.get(event), listener]);\n        return emitter;\n      };\n      var clearEvent = function(emitter, event) {\n        if (--emitter._eventsCount === 0)\n          emitter._events = /* @__PURE__ */ new Map();\n        else\n          emitter._events.delete(event);\n      };\n      var Events2 = function() {\n        function Events3() {\n          this._events = /* @__PURE__ */ new Map();\n          this._eventsCount = 0;\n        }\n        Object.defineProperty(Events3, \"VERSION\", {\n          get: function() {\n            return version_1.VERSION;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Events3.prototype.eventNames = function() {\n          return Array.from(this._events.keys());\n        };\n        Events3.prototype.listeners = function(event) {\n          var handlers = this._events.get(event);\n          if (!handlers)\n            return [];\n          if (handlers.fn)\n            return [handlers.fn];\n          for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n            ee[i] = handlers[i].fn;\n          }\n          return ee;\n        };\n        Events3.prototype.listenerCount = function(event) {\n          var listeners = this._events.get(event);\n          if (!listeners)\n            return 0;\n          if (listeners.fn)\n            return 1;\n          return listeners.length;\n        };\n        Events3.prototype.emit = function(event) {\n          var _a, _b;\n          var args = [];\n          for (var _i = 1; _i < arguments.length; _i++) {\n            args[_i - 1] = arguments[_i];\n          }\n          if (!this._events.has(event))\n            return false;\n          var listeners = this._events.get(event);\n          var i;\n          if (listeners.fn) {\n            if (listeners.once)\n              this.removeListener(event, listeners.fn, void 0, true);\n            return (_a = listeners.fn).call.apply(_a, __spreadArray([listeners.context], args)), true;\n          } else {\n            var length_1 = listeners.length;\n            for (i = 0; i < length_1; i++) {\n              if (listeners[i].once)\n                this.removeListener(event, listeners[i].fn, void 0, true);\n              (_b = listeners[i].fn).call.apply(_b, __spreadArray([listeners[i].context], args));\n            }\n          }\n          return true;\n        };\n        Events3.prototype.on = function(event, fn, context) {\n          return addListener(this, event, fn, context, false);\n        };\n        Events3.prototype.once = function(event, fn, context) {\n          return addListener(this, event, fn, context, true);\n        };\n        Events3.prototype.removeListener = function(event, fn, context, once) {\n          if (!this._events.has(event))\n            return this;\n          if (!fn) {\n            clearEvent(this, event);\n            return this;\n          }\n          var listeners = this._events.get(event);\n          if (listeners.fn) {\n            if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n              clearEvent(this, event);\n            }\n          } else {\n            for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n              if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                events.push(listeners[i]);\n              }\n            }\n            if (events.length)\n              this._events.set(event, events.length === 1 ? events[0] : events);\n            else\n              clearEvent(this, event);\n          }\n          return this;\n        };\n        Events3.prototype.removeAllListeners = function(event) {\n          if (event) {\n            if (this._events.delete(event))\n              clearEvent(this, event);\n          } else {\n            this._events = /* @__PURE__ */ new Map();\n            this._eventsCount = 0;\n          }\n          return this;\n        };\n        Object.defineProperty(Events3.prototype, \"off\", {\n          get: function() {\n            return this.removeListener;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        Object.defineProperty(Events3.prototype, \"addListener\", {\n          get: function() {\n            return this.on;\n          },\n          enumerable: false,\n          configurable: true\n        });\n        return Events3;\n      }();\n      exports.Events = Events2;\n    }\n  });\n\n  // node_modules/@geckos.io/common/lib/bridge.js\n  var import_events = __toESM(require_cjs(), 1);\n  var Bridge = class {\n    constructor() {\n      this.eventEmitter = new import_events.Events();\n    }\n    emit(eventName, data, connection = {}) {\n      this.eventEmitter.emit(eventName, data, connection);\n    }\n    on(eventName, cb) {\n      return this.eventEmitter.on(eventName, (data, options) => {\n        cb(data, options);\n      });\n    }\n    removeAllListeners() {\n      this.eventEmitter.removeAllListeners();\n    }\n  };\n  var bridge = new Bridge();\n\n  // node_modules/@geckos.io/common/lib/constants.js\n  var EVENTS = {\n    CONNECT: \"connect\",\n    CONNECTION: \"connection\",\n    DATA_CHANNEL_IS_OPEN: \"dataChannelIsOpen\",\n    DISCONNECT: \"disconnect\",\n    DISCONNECTED: \"disconnected\",\n    DROP: \"dropped\",\n    ERROR: \"error\",\n    RAW_MESSAGE: \"rawMessage\",\n    RECEIVED_FROM_DATA_CHANNEL: \"receiveFromDataChannel\",\n    SEND_OVER_DATA_CHANNEL: \"sendOverDataChannel\"\n  };\n  var ERRORS = {\n    BROWSER_NOT_SUPPORTED: \"BROWSER_NOT_SUPPORTED\",\n    COULD_NOT_PARSE_MESSAGE: \"COULD_NOT_PARSE_MESSAGE\",\n    DROPPED_FROM_BUFFERING: \"DROPPED_FROM_BUFFERING\",\n    MAX_MESSAGE_SIZE_EXCEEDED: \"MAX_MESSAGE_SIZE_EXCEEDED\"\n  };\n\n  // node_modules/@geckos.io/common/lib/types.js\n  var ArrayBufferView = Object.getPrototypeOf(Object.getPrototypeOf(new Uint8Array())).constructor;\n\n  // node_modules/@geckos.io/common/lib/helpers.js\n  var tick = typeof Promise == \"function\" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout;\n  var isStringMessage = (data) => {\n    return typeof data === \"string\";\n  };\n  var isBufferMessage = (data) => {\n    return data instanceof ArrayBuffer || data instanceof ArrayBufferView;\n  };\n  var isJSONMessage = (data) => {\n    try {\n      if (typeof data !== \"string\")\n        return false;\n      if (!isNaN(parseInt(data)))\n        return false;\n      JSON.parse(data);\n      return true;\n    } catch (error) {\n      return false;\n    }\n  };\n\n  // node_modules/@geckos.io/common/lib/parseMessage.js\n  var ParseMessage = (ev) => {\n    let { data } = ev;\n    if (!data)\n      data = ev;\n    const isBuffer = isBufferMessage(data);\n    const isJson = isJSONMessage(data);\n    const isString = isStringMessage(data);\n    if (isJson) {\n      const object = JSON.parse(data);\n      const key = Object.keys(object)[0];\n      const value = object[key];\n      return { key, data: value };\n    }\n    if (isBuffer) {\n      return { key: EVENTS.RAW_MESSAGE, data };\n    }\n    if (isString) {\n      return { key: EVENTS.RAW_MESSAGE, data };\n    }\n    return { key: \"error\", data: new Error(ERRORS.COULD_NOT_PARSE_MESSAGE) };\n  };\n  var parseMessage_default = ParseMessage;\n\n  // node_modules/@geckos.io/common/lib/sendMessage.js\n  var SendMessage = (dataChannel, maxMessageSize, eventName, data = null) => {\n    var _a;\n    const send = (data2, isBuffer) => {\n      var _a2;\n      const bytes = (_a2 = data2.byteLength) !== null && _a2 !== void 0 ? _a2 : data2.length * 2;\n      if (typeof maxMessageSize === \"number\" && bytes > maxMessageSize) {\n        throw new Error(`maxMessageSize of ${maxMessageSize} exceeded`);\n      } else {\n        Promise.resolve().then(() => {\n          if (dataChannel.send)\n            dataChannel.send(data2);\n          else {\n            if (!isBuffer)\n              dataChannel.sendMessage(data2);\n            else\n              dataChannel.sendMessageBinary(Buffer.from(data2));\n          }\n        }).catch((error) => {\n          console.log(\"error\", error);\n        });\n      }\n    };\n    if (!dataChannel)\n      return;\n    if (dataChannel.readyState === \"open\" || ((_a = dataChannel.isOpen) === null || _a === void 0 ? void 0 : _a.call(dataChannel))) {\n      try {\n        if (eventName === EVENTS.RAW_MESSAGE && data !== null && (isStringMessage(data) || isBufferMessage(data))) {\n          send(data, isBufferMessage(data));\n        } else {\n          send(JSON.stringify({ [eventName]: data }), false);\n        }\n      } catch (error) {\n        console.error(\"Error in sendMessage.ts: \", error.message);\n        return error;\n      }\n    }\n  };\n  var sendMessage_default = SendMessage;\n\n  // node_modules/@geckos.io/client/lib/wrtc/connectionsManager.js\n  var ConnectionsManagerClient = class {\n    constructor(url, authorization, label, rtcConfiguration) {\n      this.url = url;\n      this.authorization = authorization;\n      this.label = label;\n      this.rtcConfiguration = rtcConfiguration;\n      this.bridge = new Bridge();\n      this.onDataChannel = (ev) => {\n        const { channel } = ev;\n        if (channel.label !== this.label)\n          return;\n        this.dataChannel = channel;\n        this.dataChannel.binaryType = \"arraybuffer\";\n        this.dataChannel.onmessage = (ev2) => {\n          const { key, data } = parseMessage_default(ev2);\n          this.bridge.emit(key, data);\n        };\n      };\n    }\n    emit(eventName, data = null) {\n      sendMessage_default(this.dataChannel, this.maxMessageSize, eventName, data);\n    }\n    async fetchAdditionalCandidates(host, id) {\n      var _a;\n      if (((_a = this.dataChannel) === null || _a === void 0 ? void 0 : _a.readyState) === \"closed\")\n        return;\n      const res = await fetch(`${host}/connections/${id}/additional-candidates`, {\n        method: \"GET\",\n        headers: {\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      if (res.ok) {\n        const candidates = await res.json();\n        candidates.forEach((c) => {\n          this.localPeerConnection.addIceCandidate(c);\n        });\n      }\n    }\n    async connect() {\n      const host = `${this.url}/.wrtc/v2`;\n      let headers = { \"Content-Type\": \"application/json\" };\n      if (this.authorization)\n        headers = { ...headers, [\"Authorization\"]: this.authorization };\n      let userData = {};\n      try {\n        const res = await fetch(`${host}/connections`, {\n          method: \"POST\",\n          headers\n        });\n        if (res.status >= 300) {\n          throw {\n            name: \"Error\",\n            message: `Connection failed with status code ${res.status}.`,\n            status: res.status,\n            statusText: res.statusText\n          };\n        }\n        const json = await res.json();\n        userData = json.userData;\n        this.remotePeerConnection = json;\n      } catch (error) {\n        console.error(error.message);\n        return { error };\n      }\n      const { id, localDescription } = this.remotePeerConnection;\n      const configuration = {\n        sdpSemantics: \"unified-plan\",\n        ...this.rtcConfiguration\n      };\n      const RTCPc = RTCPeerConnection || webkitRTCPeerConnection;\n      this.localPeerConnection = new RTCPc(configuration);\n      const showBackOffIntervals = (attempts = 10, initial = 50, factor = 1.8, jitter = 20) => Array(attempts).fill(0).map((_, index) => parseInt((initial * factor ** index).toString()) + parseInt((Math.random() * jitter).toString()));\n      showBackOffIntervals().forEach((ms) => {\n        setTimeout(() => {\n          this.fetchAdditionalCandidates(host, id).catch(() => {\n          });\n        }, ms);\n      });\n      try {\n        await this.localPeerConnection.setRemoteDescription(localDescription);\n        this.localPeerConnection.addEventListener(\"datachannel\", this.onDataChannel, { once: true });\n        const originalAnswer = await this.localPeerConnection.createAnswer();\n        const updatedAnswer = new RTCSessionDescription({\n          type: \"answer\",\n          sdp: originalAnswer.sdp\n        });\n        await this.localPeerConnection.setLocalDescription(updatedAnswer);\n        try {\n          await fetch(`${host}/connections/${id}/remote-description`, {\n            method: \"POST\",\n            body: JSON.stringify(this.localPeerConnection.localDescription),\n            headers: {\n              \"Content-Type\": \"application/json\"\n            }\n          });\n        } catch (error) {\n          console.error(error.message);\n          return { error };\n        }\n        const waitForDataChannel = () => {\n          return new Promise((resolve) => {\n            this.localPeerConnection.addEventListener(\"datachannel\", () => {\n              resolve();\n            }, { once: true });\n          });\n        };\n        if (!this.dataChannel)\n          await waitForDataChannel();\n        return {\n          userData,\n          localPeerConnection: this.localPeerConnection,\n          dataChannel: this.dataChannel,\n          id\n        };\n      } catch (error) {\n        console.error(error.message);\n        this.localPeerConnection.close();\n        return { error };\n      }\n    }\n  };\n\n  // node_modules/@geckos.io/client/lib/wrtc/peerConnection.js\n  var PeerConnection = class {\n    async connect(connectionsManager) {\n      const webRTCPcSupported = RTCPeerConnection || webkitRTCPeerConnection;\n      if (webRTCPcSupported) {\n        const { localPeerConnection, dataChannel, id, userData, error } = await connectionsManager.connect();\n        if (error)\n          return { error };\n        if (!localPeerConnection || !dataChannel || !id || !userData)\n          return { error: new Error('Something went wrong in \"await connectionsManager.connect()\"') };\n        this.localPeerConnection = localPeerConnection;\n        this.dataChannel = dataChannel;\n        this.id = id;\n        return { userData };\n      } else {\n        const error = new Error(ERRORS.BROWSER_NOT_SUPPORTED);\n        console.error(error.message);\n        return { error };\n      }\n    }\n  };\n\n  // node_modules/@geckos.io/common/lib/makeRandomId.js\n  var makeRandomId = (length = 24) => {\n    const possible = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n    let id = \"\";\n    for (let i = 0; i < length; i++) {\n      id += possible.charAt(Math.floor(Math.random() * possible.length));\n    }\n    return id;\n  };\n  var makeRandomId_default = makeRandomId;\n\n  // node_modules/@geckos.io/common/lib/runInterval.js\n  var runInterval = (interval = 200, runs = 1, cb) => {\n    let counter = 0;\n    if (typeof cb !== \"function\") {\n      console.error(\"You have to define your callback function!\");\n      return;\n    }\n    const i = setInterval(() => {\n      cb();\n      counter++;\n      if (counter === runs - 1) {\n        clearInterval(i);\n      }\n    }, interval);\n    cb();\n  };\n  var runInterval_default = runInterval;\n\n  // node_modules/@geckos.io/common/lib/reliableMessage.js\n  var makeReliable = (options, cb) => {\n    const { interval = 150, runs = 10 } = options;\n    const id = makeRandomId_default(24);\n    runInterval_default(interval, runs, () => {\n      cb(id);\n    });\n  };\n\n  // node_modules/@geckos.io/client/lib/geckos/channel.js\n  var ClientChannel = class {\n    constructor(url, authorization, port, label, rtcConfiguration) {\n      this.userData = {};\n      this.receivedReliableMessages = [];\n      this.url = port ? `${url}:${port}` : url;\n      this.connectionsManager = new ConnectionsManagerClient(this.url, authorization, label, rtcConfiguration);\n      this.bridge = this.connectionsManager.bridge;\n      this.bridge.on(EVENTS.DISCONNECTED, () => this.bridge.removeAllListeners());\n    }\n    onconnectionstatechange() {\n      const lpc = this.peerConnection.localPeerConnection;\n      lpc.onconnectionstatechange = () => {\n        if (lpc.connectionState === \"disconnected\" || lpc.connectionState === \"closed\")\n          this.bridge.emit(EVENTS.DISCONNECTED);\n      };\n    }\n    get id() {\n      return this.peerConnection.id;\n    }\n    close() {\n      this.peerConnection.localPeerConnection.close();\n      this.bridge.emit(EVENTS.DISCONNECTED);\n      try {\n        const host = `${this.url}/.wrtc/v2`;\n        fetch(`${host}/connections/${this.id}/close`, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\"\n          }\n        });\n      } catch (error) {\n        console.error(error.message);\n      }\n    }\n    emit(eventName, data = null, options) {\n      if (options && options.reliable) {\n        makeReliable(options, (id) => this.connectionsManager.emit(eventName, {\n          MESSAGE: data,\n          RELIABLE: 1,\n          ID: id\n        }));\n      } else {\n        this.connectionsManager.emit(eventName, data);\n      }\n    }\n    get raw() {\n      return {\n        emit: (rawMessage) => this.emit(EVENTS.RAW_MESSAGE, rawMessage)\n      };\n    }\n    onRaw(callback) {\n      this.bridge.on(EVENTS.RAW_MESSAGE, (rawMessage) => {\n        const cb = (rawMessage2) => callback(rawMessage2);\n        cb(rawMessage);\n      });\n    }\n    async onConnect(callback) {\n      var _a;\n      this.peerConnection = new PeerConnection();\n      const response = await this.peerConnection.connect(this.connectionsManager);\n      if (response.error)\n        callback(response.error);\n      else {\n        if (response.userData)\n          this.userData = response.userData;\n        this.maxMessageSize = this.connectionsManager.maxMessageSize = (_a = this.peerConnection.localPeerConnection.sctp) === null || _a === void 0 ? void 0 : _a.maxMessageSize;\n        this.onconnectionstatechange();\n        callback();\n      }\n    }\n    onDisconnect(callback) {\n      this.bridge.on(EVENTS.DISCONNECTED, callback);\n    }\n    on(eventName, callback) {\n      this.bridge.on(eventName, (data) => {\n        const isReliableMessage = data && data.RELIABLE === 1 && data.ID !== \"undefined\";\n        const expireTime = 15e3;\n        const deleteExpiredReliableMessages = () => {\n          const currentTime = new Date().getTime();\n          this.receivedReliableMessages.forEach((msg, index, object) => {\n            if (msg.expire <= currentTime) {\n              object.splice(index, 1);\n            }\n          });\n        };\n        if (isReliableMessage) {\n          deleteExpiredReliableMessages();\n          if (this.receivedReliableMessages.filter((obj) => obj.id === data.ID).length === 0) {\n            this.receivedReliableMessages.push({\n              id: data.ID,\n              timestamp: new Date(),\n              expire: new Date().getTime() + expireTime\n            });\n            callback(data.MESSAGE);\n          } else {\n          }\n        } else {\n          callback(data);\n        }\n      });\n    }\n  };\n  var geckosClient = (options = {}) => {\n    const { authorization = void 0, iceServers = [], iceTransportPolicy = \"all\", label = \"geckos.io\", port = 9208, url = `${location.protocol}//${location.hostname}` } = options;\n    return new ClientChannel(url, authorization, port, label, { iceServers, iceTransportPolicy });\n  };\n  var channel_default = geckosClient;\n\n  // code/adapters/geckos-client.ts\n  var logger = new gdjs.Logger(\"THNK - Geckos.io Adapter\");\n  THNK.GeckosClientAdapter = class GeckosClientAdapter extends THNK.ClientAdapter {\n    constructor(ip, port) {\n      super();\n      this.connection = null;\n      this.ip = `http://${ip}`;\n      this.port = port;\n    }\n    async prepare() {\n      this.connection = channel_default({ url: this.ip, port: this.port, label: \"THNK\" });\n      await new Promise(\n        (resolve, reject) => this.connection.onConnect((error) => {\n          if (error)\n            return reject(error.message);\n          this.connection.onRaw(\n            (message) => this.onMessage(message)\n          );\n          this.connection.onDisconnect(() => this.onDisconnection());\n          resolve();\n        })\n      );\n    }\n    close() {\n      if (this.connection)\n        this.connection.close();\n    }\n    doSendMessage(message) {\n      if (!this.connection) {\n        return logger.error(\n          \"Tried to send a message on an unestablished connection!\"\n        );\n      }\n      this.connection.raw.emit(\n        message.buffer.slice(message.buffer.byteLength - message.byteLength)\n      );\n    }\n  };\n})();\n/**\n * @package      npmjs.com/package/@yandeu/events (events.min.js)\n *\n * @author       Arnout Kazemier (https://github.com/3rd-Eden)\n * @copyright    Copyright (c) 2014 Arnout Kazemier\n * @license      {@link https://github.com/primus/eventemitter3/blob/master/LICENSE|MIT}\n *\n * @author       Yannick Deubel (https://github.com/yandeu)\n * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/yandeu/events\n * @license      {@link https://github.com/yandeu/events/blob/master/LICENSE|MIT}\n */\n",
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Connects to a geckos.io THNK server.",
      "fullName": "Connect to server",
      "functionType": "Action",
      "group": "",
      "name": "ConnectToServer",
      "private": false,
      "sentence": "Connect to server at _PARAM1_:_PARAM2_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": "THNK.client.startClient(\n    runtimeScene,\n    new THNK.GeckosClientAdapter(\n        eventsFunctionContext.getArgument(\"Host\"),\n        eventsFunctionContext.getArgument(\"Port\")\n    )\n);\n",
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "Hostname (URL or IP address)",
          "longDescription": "",
          "name": "Host",
          "optional": false,
          "supplementaryInformation": "",
          "type": "string"
        },
        {
          "codeOnly": false,
          "defaultValue": "",
          "description": "The port the server is hosted on",
          "longDescription": "",
          "name": "Port",
          "optional": false,
          "supplementaryInformation": "",
          "type": "expression"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}