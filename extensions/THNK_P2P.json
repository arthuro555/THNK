{
  "author": "",
  "category": "Network",
  "extensionNamespace": "",
  "fullName": "THNK Framework - P2P adapter",
  "helpPath": "https://thnk.cloud/",
  "iconUrl": "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgdmVyc2lvbj0iMS4xIiBpZD0ibWRpLWxhbiIgd2lkdGg9IjI0IiBoZWlnaHQ9IjI0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPjxwYXRoIGQ9Ik0xMCwyQzguODksMiA4LDIuODkgOCw0VjdDOCw4LjExIDguODksOSAxMCw5SDExVjExSDJWMTNINlYxNUg1QzMuODksMTUgMywxNS44OSAzLDE3VjIwQzMsMjEuMTEgMy44OSwyMiA1LDIySDlDMTAuMTEsMjIgMTEsMjEuMTEgMTEsMjBWMTdDMTEsMTUuODkgMTAuMTEsMTUgOSwxNUg4VjEzSDE2VjE1SDE1QzEzLjg5LDE1IDEzLDE1Ljg5IDEzLDE3VjIwQzEzLDIxLjExIDEzLjg5LDIyIDE1LDIySDE5QzIwLjExLDIyIDIxLDIxLjExIDIxLDIwVjE3QzIxLDE1Ljg5IDIwLjExLDE1IDE5LDE1SDE4VjEzSDIyVjExSDEzVjlIMTRDMTUuMTEsOSAxNiw4LjExIDE2LDdWNEMxNiwyLjg5IDE1LjExLDIgMTQsMkgxME0xMCw0SDE0VjdIMTBWNE01LDE3SDlWMjBINVYxN00xNSwxN0gxOVYyMEgxNVYxN1oiIC8+PC9zdmc+",
  "name": "THNK_P2P",
  "previewIconUrl": "https://resources.gdevelop-app.com/assets/Icons/lan.svg",
  "shortDescription": "The P2P networking support module for the THNK framework.",
  "version": "1.0.0",
  "description": "Allows to host a THNK server on a P2P connection, and for other peers to connect to it via the server's P2P ID.",
  "tags": [
    "THNK",
    "adapter",
    "network",
    "p2p",
    "peer",
    "ICE"
  ],
  "authorIds": [
    "ZgrsWuRTAkXgeuPV9bo0zuEcA2w1"
  ],
  "dependencies": [],
  "eventsFunctions": [
    {
      "fullName": "",
      "functionType": "Action",
      "name": "onFirstSceneLoaded",
      "sentence": "",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "// Load THNK P2P Adapter (https://github.com/arthuro555/THNK)",
            "\"use strict\";",
            "(() => {",
            "  // code/adapters/p2p.ts",
            "  if(!window.THNK)window.THNK={};let THNK=window.THNK;",
            "  ((THNK2) => {",
            "    const logger = new gdjs.Logger(\"THNK - P2P Adapter\");",
            "    class P2PConnectionAwaiter extends gdjs.AsyncTask {",
            "      constructor(peerID) {",
            "        super();",
            "        this.peerID = peerID;",
            "      }",
            "      update() {",
            "        return !!gdjs.evtTools.p2p.getConnectionInstance(this.peerID);",
            "      }",
            "    }",
            "    class P2PClientAdapter extends THNK2.ClientAdapter {",
            "      constructor(peerID) {",
            "        super();",
            "        this.connection = null;",
            "        this.boundPreEventsCallback = () => this.preEventsCallback();",
            "        this.peerID = peerID;",
            "      }",
            "      preEventsCallback() {",
            "        if (!gdjs.evtTools.p2p.getConnectionInstance(this.peerID)) {",
            "          this.onDisconnection();",
            "        }",
            "      }",
            "      async prepare(runtimeScene) {",
            "        this.connection = gdjs.evtTools.p2p.getConnectionInstance(",
            "          this.peerID",
            "        );",
            "        if (!this.connection) {",
            "          gdjs.evtTools.p2p.connect(this.peerID);",
            "          this.connection = await new Promise(",
            "            (resolve) => {",
            "              runtimeScene.getAsyncTasksManager().addTask(",
            "                new P2PConnectionAwaiter(this.peerID),",
            "                () => resolve(",
            "                  gdjs.evtTools.p2p.getConnectionInstance(",
            "                    this.peerID",
            "                  )",
            "                )",
            "              );",
            "            }",
            "          );",
            "        }",
            "        this.connection.on(",
            "          \"data\",",
            "          (data) => this.onMessage(new Uint8Array(data))",
            "        );",
            "        gdjs.registerRuntimeScenePreEventsCallback(this.boundPreEventsCallback);",
            "      }",
            "      close() {",
            "        gdjs.evtTools.p2p.disconnectFromPeer(this.peerID);",
            "        gdjs._unregisterCallback(this.boundPreEventsCallback);",
            "      }",
            "      doSendMessage(message) {",
            "        if (!this.connection) {",
            "          return logger.error(",
            "            \"Tried to send a message on an unestablished connection!\"",
            "          );",
            "        }",
            "        this.connection.send(",
            "          message.buffer.slice(message.buffer.byteLength - message.byteLength)",
            "        );",
            "      }",
            "    }",
            "    THNK2.P2PClientAdapter = P2PClientAdapter;",
            "    class P2PServerAdapter extends THNK2.ServerAdapter {",
            "      constructor() {",
            "        super(...arguments);",
            "        this.boundPreEventsCallback = () => this.preEventsCallback();",
            "      }",
            "      preEventsCallback() {",
            "        if (gdjs.evtTools.p2p.onConnection()) {",
            "          const connectedPeer = gdjs.evtTools.p2p.getConnectedPeer();",
            "          this.onConnection(connectedPeer);",
            "          const connectionInstance = gdjs.evtTools.p2p.getConnectionInstance(",
            "            connectedPeer",
            "          );",
            "          connectionInstance.on(\"data\", (data) => {",
            "            this.onMessage(connectedPeer, new Uint8Array(data));",
            "          });",
            "        }",
            "        if (gdjs.evtTools.p2p.onDisconnect()) {",
            "          const disconnectedPeer = gdjs.evtTools.p2p.getDisconnectedPeer();",
            "          this.onDisconnection(disconnectedPeer);",
            "        }",
            "      }",
            "      async prepare() {",
            "        gdjs.registerRuntimeScenePreEventsCallback(this.boundPreEventsCallback);",
            "      }",
            "      close() {",
            "        gdjs._unregisterCallback(this.boundPreEventsCallback);",
            "      }",
            "      doSendMessageTo(userID, message) {",
            "        const connection = gdjs.evtTools.p2p.getConnectionInstance(userID);",
            "        if (connection) {",
            "          connection.send(",
            "            message.buffer.slice(message.buffer.byteLength - message.byteLength)",
            "          );",
            "        }",
            "      }",
            "      getServerID() {",
            "        return gdjs.evtTools.p2p.getCurrentId();",
            "      }",
            "    }",
            "    THNK2.P2PServerAdapter = P2PServerAdapter;",
            "  })(THNK || (THNK = {}));",
            "})();",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": true
        }
      ],
      "parameters": [],
      "objectGroups": []
    },
    {
      "description": "Starts a scene as a remote scene server that connected P2P peers can join. The current game will also switch and connect to the game. If you switch to another scene or start another remote scene over P2P, the local server will be shut down and connected peers disconnected.",
      "fullName": "Start a remote scene over P2P",
      "functionType": "Action",
      "name": "StartServer",
      "sentence": "Start scene _PARAM1_ over P2P",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "THNK.server.startServer(\r",
            "    new THNK.P2PServerAdapter(),\r",
            "    runtimeScene,\r",
            "    eventsFunctionContext.getArgument(\"scene\")\r",
            ");\r",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "The scene to start as a THNK P2P server",
          "name": "scene",
          "type": "sceneName"
        }
      ],
      "objectGroups": []
    },
    {
      "description": "Connect to a remote scene hosted by a P2P server.",
      "fullName": "Connect to a P2P remote scene",
      "functionType": "Action",
      "name": "ConnectToServer",
      "sentence": "Connect to scene on _PARAM1_",
      "events": [
        {
          "type": "BuiltinCommonInstructions::JsCode",
          "inlineCode": [
            "THNK.client.startClient(\r",
            "    runtimeScene,\r",
            "    new THNK.P2PClientAdapter(eventsFunctionContext.getArgument(\"PeerID\"))\r",
            ");\r",
            ""
          ],
          "parameterObjects": "",
          "useStrict": true,
          "eventsSheetExpanded": false
        }
      ],
      "parameters": [
        {
          "description": "Name of the P2P peer to connect to",
          "name": "PeerID",
          "type": "string"
        }
      ],
      "objectGroups": []
    }
  ],
  "eventsBasedBehaviors": [],
  "eventsBasedObjects": []
}